# -*- coding: utf-8 -*-
"""Audit_Risk_Detection1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hq0c22eL0oLNhEVF9LSiT6jWQMzWNsCa

# **Problem statement:**

Predict the fraudulent firm on the basis of the present and historical risk factors.

● perform data exploration, preprocessing and visualization

● implement classification model using sklearn library

● evaluate the model using appropriate performance metrics

● develop the Audit Risk Prediction system.

# **About Dataset:**
building a classification model that can predict the fraudulent firm on the basis of
the present and historical risk factors. The information about the sectors and the
counts of firms are listed respectively as Irrigation (114), Public Health (77),
Buildings and Roads (82), Forest (70), Corporate (47), Animal Husbandry (95),
Communication (1), Electrical (4), Land (5), Science and Technology (3), Tourism
(1), Fisheries (41), Industries (37), Agriculture (200).

# **Attribute Information:**
Many risk factors are examined from various areas like past records of audit
office, audit-paras, environmental conditions reports, firm reputation summary,
on-going issues report, profit-value records, loss-value records, follow-up reports
etc. After an in-depth interview with the auditors, important risk factors are
evaluated and their probability of existence is calculated from the present and
past records.
Data Set Characteristics: Multivariate
Number of Instances:777

# **Attributes:**

* **Sector-Score** : Historical risk score value of the target-unit using analytical procedure
* **LOCATION-ID** : Unique ID of the city/province.
* **PARA_A** : Discrepancy found in the planned expenditure of inspection and summary report A in Rs (in crore).
* **Score_A** : Score related to PARA_A
* **Risk_A** : Risk due to PARA_A
* **PARA_B** : Discrepancy found in the unplanned expenditure of inspection and summary report B in Rs (in crore).
* **Score_B** : Score related to PARA_B
* **Risk_B** : Risk due to PARA_B
* **TOTAL** : Total amount of discrepancy found in other reports Rs (in crore).
* **numbers** : Historical discrepancy score.
* **Score_B.1** : Score related to TOTAL
* **Risk_C** : Risk related to TOTAL
* **Money_Value** : Amount of money involved in misstatements in the past audits.
* **Score_MV** : Score related to Money_Value
* **Risk_D** : Risk related to Money_Value
* **District_Loss** :  Loss in the district due that firm
* **PROB** : Probability of that firm with respect to the whole district
* **Risk_E** : Risk due to the District_Loss
* **History** : Historic discrepancy
* **Prob** : Probability with respect to History
* **Risk_F** : Risk related to History
* **Score**
* **Inherent_Risk** :  Inherent risk is the risk posed by an error or omission in a financial statement due to a factor other than a failure of internal control.
* **CONTROL_RISK** : Control risk, which is the risk that a misstatement due to error or fraud that could occur in an assertion and that could be material, individually or in combination with other misstatements, will not be prevented or detected on a timely basis by the company's internal control.
* **Detection_Risk** : Detection risk is the chance that an auditor will fail to find material misstatements that exist in an entity's financial statements.
* **Audit_Risk** :  Total risk score using analytical procedure
* **Risk** : Risk Class assigned to an audit-case. (Target Feature)

# **Importing libraries**
"""
import pandas as pd
from sklearn.preprocessing import StandardScaler
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from imblearn.combine import SMOTEENN

data = pd.read_csv(r'D:/Audit Risk Detection/audit_risk.csv')

data.drop(['LOCATION_ID'],axis = 1,inplace = True)

data['Money_Value'].fillna((data['Money_Value'].mean()), inplace=True)

data = data.drop(['Detection_Risk'],axis = 1)

X = data.drop(['Risk'],axis = 1)
Y = data['Risk']

"""***There is an imbalance in th data so we need to balance it***"""

smote_enn = SMOTEENN(random_state=42)
X, Y = smote_enn.fit_resample(X, Y)

X_train, X_test, y_train, y_test = train_test_split(X, Y, stratify = Y,test_size = 0.3, random_state = 1)

def correlation(dataset, threshold):
    col_corr = set()  # Set of all the names of correlated columns
    corr_matrix = dataset.corr()
    for i in range(len(corr_matrix.columns)):
        for j in range(i):
            if (abs(corr_matrix.iloc[i, j]) > threshold) and (corr_matrix.columns[j] not in col_corr): # we are interested in absolute coeff value
                colname = corr_matrix.columns[i]  # getting the name of column
                col_corr.add(colname)
    return col_corr

corr_features = correlation(X_train, 0.7)

X_train.drop(corr_features,axis = 1,inplace = True)


X_test.drop(corr_features,axis = 1,inplace = True)


features_names = X_train.columns


scale = StandardScaler()
X_train = scale.fit_transform(X_train)
X_test = scale.transform(X_test)


random_forest = RandomForestClassifier(n_estimators = 100,criterion = 'entropy',random_state = 47)
random_forest.fit(X_train,y_train)

"""# **Predicting Output using the most accurate model**

***From the ROC AUC scores it can be observed that Random Forest is the best model***
"""
def check(di):
  global features_names
  global random_forest
  global X
  '''lst = ['Sector_score', 'LOCATION_ID', 'PARA_A', 'Score_A', 'Risk_A', 'PARA_B',
        'Score_B', 'Risk_B', 'TOTAL', 'numbers', 'Score_B.1', 'Risk_C',
        'Money_Value', 'Score_MV', 'Risk_D', 'District_Loss', 'PROB', 'RiSk_E',
        'History', 'Prob', 'Risk_F', 'Score', 'Inherent_Risk', 'CONTROL_RISK',
        'Detection_Risk', 'Audit_Risk']

  j = 0
  if opt == "Row number":
    l = list(X.iloc[int(num)])
    for i in range(len(lst)):
      if(j < len(features_names)) and (lst[i] == features_names[j]):
        di[features_names[j]] = l[i]
        j += 1'''
  input_test = pd.DataFrame(columns=features_names)
  input_test = input_test.append(di, ignore_index=True)
  input_test = scale.transform(input_test)
  y_pred_test = random_forest.predict(input_test)
  if y_pred_test[0] == 0:
    return "Not Fraud"
  return "Fraud"
